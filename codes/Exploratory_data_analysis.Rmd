---
title: "Exploratory_data_analysis"
author: "Charles Anchang"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: cosmo
    highlight: monochrome
    toc: yes
    toc_float: no
    toc_depth: 6
    code_folding: hide
  github_document:
    theme: cosmo
    highlight: monochrome
    toc: yes
    toc_float: no
    toc_depth: 6
    code_folding: hide
  word_document:
    toc: yes
    toc_depth: '6'
  pdf_document:
    toc: yes
    toc_depth: '6'
editor_options:
  chunk_output_type: console
---

```{css, echo=FALSE}
<style>
body, h1, h2, h3, h4 {
    font-family: "Bookman", serif;
}

body {
    color: #333333;
}
a, a:hover {
    color: red;
}
pre {
    font-size: 10px;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## **Introduction**

RNA sequencing is a technique whereby RNA transcripts are converted to complementary DNA (cDNA) which is then sequenced to generate reads and the reads and mapped to a reference genome to generate counts which can be analysed statistically. But the statistical approaches differ than those used for microarrays because the RNA seq data consists of countsÂ´and not intensities. Counts are modeled using the Poisson or negative binomial distribution. These techniques are implemented in the **EdgeR** and **DESeq2** packages which are some of the most widely used RNA seq data analysis. Major complications with RNA seq data analysis are the need to account for the effects of splicing and to account for isoformy. In this analysis, I will not touch details on this topic. However So, while we have approaches like edgeR, DESeq, and **DEXSeq** that basically count each gene or each exon and quantifies the amount. We also have techniques that try to determine from the reads what transcripts are present. Some of these actually try to do it from scratch, without a reference genome.
Examples of these methods are **Trinity Oases**, **Cufflinks**, and **Scripture**.

I will however look at basic statistical approaches commonly used in RNA seq analysis.

## **Load libraries**

```{r}
library(dplyr) # wrangling
```


## **Transcriptome alignment assessment**

At a previous step not detailed in this analysis, transcript- and gene-level expression was calculated by probabilistic alignment using the RSEM software. The two result are saved in the **raw_data** folder.

```{r}
list.files("raw_data")
genes <- read.table("raw_data/SRR1039508.genes.results",
                    header = TRUE, stringsAsFactors = TRUE)

head(genes) %>%
  knitr::kable()
isoforms <- read.table("raw_data/SRR1039508.isoforms.results",
                       header = TRUE, stringsAsFactors = TRUE)
head(isoforms) %>%
  knitr::kable()
```

Both genes and isoforms have a column names the **FPKM(fragments per kilobase of sequence per million mapped reads) **.

I will confirm with the *split()* and *sapply()* functions that the FPKM column in genes is the sum of the FPKM colum in isoforms.

```{r}
fpkm.per.gene <- split(isoforms$FPKM, isoforms$gene_id)
head(sapply(fpkm.per.gene, sum))
head(genes$FPKM)
```

Alternatively

```{r}
isoforms %>% group_by(gene_id) %>% summarize(sum = sum(FPKM)) 
```

I will obtain FPKM values from the genes values and log transform it and make a histogram. But before that, I will start by removing all genes with FPKM values of 0. The log transformation will be $\log10(x + 1)$.

```{r}
genes2 <- genes[genes$FPKM > 0, ]
genes2$gene_id <- droplevels(genes2$gene_id)
isoforms2 <- isoforms[isoforms$gene_id %in% genes2$gene_id, ]
isoforms2$gene_id <- droplevels(isoforms2$gene_id)
```

To verify that the gene_id column in genes2 is equal to the levels of the gene_id column in isoforms2.

```{r}
stopifnot(all(genes2$gene_id == levels(isoforms2$gene_id)))
```

Plot of effective length vs expected count:

```{r}
head(genes2)
plot(log(genes2$effective_length),
     log(genes2$expected_count))
```

**Make a histogram of the FPKM in genes2**

```{r fig.align='center'}
genes2_fpkm <- log10(genes2$FPKM)
genes2_fpkm_pos <- genes2_fpkm[genes2_fpkm > 0]
median(genes2$FPKM)
hist(log10(genes2$FPKM))
```

**With isoforms2 , calculate the maximum IsoPct for each gene**

```{r}
head(isoforms2)

max.iso <- isoforms2 %>%
              group_by(gene_id) %>%
              summarize(max_isopc = max(IsoPct))
hist(max.iso$max_isopc)
mean(max.iso$max_isopc > 95)
```

**Is there a relationship between total expression and the maximum IsoPct for each gene?**

```{r fig.align='center'}
plot(max.iso$max_isopc,
     log(max.iso$max_isopc))
boxplot(split(log10(genes2$FPKM), 
              cut(max.iso$max_isopc, 5)), xlab="max.iso", ylab="log10 FPKM")
```

**Calculate the number of isoforms per gene, and plot the maximum IsoPct against the number of isoforms:**

```{r fig.align='center'}
num.iso <- as.numeric(table(isoforms2$gene_id))
plot(num.iso, max.iso$max_isopc)

barplot(table(num.iso))
barplot(table(num.iso[num.iso < 15]))
```

**TPM (transcripts per million)**, is a linear scaling of the FPKM, such that we would expect a gene with 1 TPM to have one molecule in a population of one million mRNAs.

With genes2, plot the TPM over the FPKM.

Confirm that TPM is equal to: (FPKM / sum(FPKM)) * 1e6

## **Normalization and EDA of gene counts**

In this section, I will be examining the gene level expression from a study which studies the RNA-seq transcription profiling in airway smooth muscle tissue.

The treatment of interest in this study was **dexamethasone** that binds to the glucocorticoid receptor and in general provides an anti-inflammatory response. When used in asthma, it helps to suppress autoimmune reactions which have undesirable symptoms. We have eight samples, four treated and four untreated. The files needed for the analysis are found in the bioconductor package called **airway**.

### Count the number of reads which uniquely align to exns of different genes.

Load the data, contained in **bam** and **gtf** files. GTF files has information about genes in the subset of chromosomes on interest. Please note that the bam and gtf files analysed here are not full but a subset.

```{r}
# BiocManager::install("airway")
library(airway)
library(tidyverse)

dir <- system.file("extdata", package = "airway", mustWork = TRUE)
csv.file <- file.path(dir, "sample_table.csv") # contains th counts table for all genes and samples
sample.table <- read.csv(csv.file, row.names = 1)
bam.files <- file.path(dir, paste0(sample.table$Run, "_subset.bam")) # subset bam files
gtf.file <- file.path(dir, "Homo_sapiens.GRCh37.75_subset.gtf")
```

Look at the counts matrix

```{r}
sample.table %>%
  head %>%
  knitr::kable()
```

### Building a counts matrix

```{r}
# BiocManager::install("Rsamtools")
library(Rsamtools)
bam.list <- BamFileList(bam.files) # yieldsize specifies how many reads to be read in at a time by any function that will use the bam files. Best to read all at once, why I do not specify it.
# BiocManager::install("GenomicFeatures")
library(GenomicFeatures) # helps to build a transcript database which contains all info about different genes, transcripts and exons
txdb <- makeTxDbFromGFF(gtf.file, format = "gtf") # txdb is a transcript database (db)
exons.by.gene <- exonsBy(txdb, by = "gene") # extract a GRanges list in which each element specifies a gene and within that element, we have exons for that gene. 
```

Txdb objects are SQLite databases and can be saved with **saveDb** and can be loaded with **loadDb**. 

Exploring the GRAnges object (exons.by.gene)

```{r}
exons.by.gene[[1]] %>%
  head %>%
  knitr::kable()
```

If we look at the first element in exons.by.gene object as in the table above, we get the exons for the first gene and the corresponding chromosome to which it is annotated.

```{r}
length(exons.by.gene)
```

The length of exons.by.gene gives us the number of genes in our subset.

```{r}
summary(elementNROWS(exons.by.gene))
```

The function *elementNROWS()* gives us the number of exons for every gene. We can see that some genes have only one exon, the another 70 and the mean number of exons is 12 in this subset.

```{r}
library(GenomicAlignments)
se <- summarizeOverlaps(exons.by.gene,
                        bam.list,
                        mode = "Union",
                        singleEnd = FALSE, # we want to count paired end reads
                        ignore.strand = TRUE, # we have unstranded rna seq data
                        fragments = TRUE) # used when we have paired end data
colData(se) <- DataFrame(sample.table)
```

So the actual count table is stored in a SummarizedExperiment in the assay slot.

```{r}
colData(se)
rowRanges(se)
```

```{r}
dim(assay(se))
```

```{r}
colSums(assay(se))
```


```{r}
# BiocManager::install("Rsubread")
library(Rsubread)

# function below is an alternate function to count read in genes
fc <- featureCounts(bam.files,
                    annot.ext = gtf.file,
                    isGTFAnnotationFile = TRUE,
                    isPairedEnd = TRUE)
names(fc)
fc$counts %>%
  head %>%
  knitr::kable()
```

below I compare the first sample counts for the summarizeOverlaps call and for the counts.
```{r fig.align='center'}
plot(assay(se)[, 1], fc$counts[match(rownames(se),
                                      rownames(fc$counts)), 1]);
abline(0, 1)
```

From the graph above we see that the counts fall in the y = x line, indicatint that both methods yield similar results.

## **Normalizing for sequencing depth**

### Visualising sample - sample distances

```{r fig.align='center'}
library(airway)
data(airway)
airway
```

```{r}
colData(airway)
```

The table above contains metadata.

```{r}
rowRanges(airway)
```

The above this is GRangesList, where each element is a gene and it contains the exons of that gene.

```{r}
head(assay(airway))
```

The table above contains the counts of the various genes for each sample. The counts are the number of paired-end reads which align to each gene.

However, to be accurate about the number of reads which align to each gene, there are a number of issues to account for. One of them is the sequencing depth. The sequencing depth is the number of reads which aligned to genes.

```{r}
colSums(assay(airway))
```

The results from the command above gives the number of paired end reads which align the genes of each sample and we can sort that by  million.

```{r}
sort(colSums(assay(airway)))/ 10e6
```

We see the range is from 15 million to 30 million and this is a technical artifact we want to account for.
